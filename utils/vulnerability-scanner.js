/**
 * Automated Vulnerability Scanner
 * Security scanning and vulnerability detection
 *
 * Based on 2025 security best practices:
 * - Automated dependency scanning
 * - Security header validation
 * - Common vulnerability checks (OWASP Top 10)
 * - TLS/SSL configuration audit
 * - Sensitive data exposure detection
 *
 * @module utils/vulnerability-scanner
 */

const fs = require('fs').promises;
const path = require('path');
const crypto = require('crypto');
const { EventEmitter } = require('events');

class VulnerabilityScanner extends EventEmitter {
  constructor(options = {}) {
    super();

    this.options = {
      scanInterval: options.scanInterval || 86400000, // 24 hours
      enableAutoScan: options.enableAutoScan || false,
      reportDir: options.reportDir || './reports/security',
      severity: options.severity || ['critical', 'high', 'medium', 'low'],
      checks: options.checks || [
        'dependencies',
        'headers',
        'tls',
        'secrets',
        'permissions',
        'paths'
      ],
      ...options
    };

    this.vulnerabilities = [];
    this.scanTimer = null;
    this.lastScan = null;

    this.init();
  }

  /**
   * Initialize scanner
   */
  async init() {
    try {
      await fs.mkdir(this.options.reportDir, { recursive: true });

      if (this.options.enableAutoScan) {
        this.startAutoScan();
      }

      console.log('[VulnScanner] Initialized');
    } catch (error) {
      console.error('[VulnScanner] Initialization failed:', error);
    }
  }

  /**
   * Run full vulnerability scan
   * @returns {Promise<Object>} Scan results
   */
  async scan() {
    console.log('[VulnScanner] Starting security scan...');

    const startTime = Date.now();
    this.vulnerabilities = [];

    const results = {
      timestamp: new Date().toISOString(),
      duration: 0,
      checks: {},
      summary: {
        total: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0
      },
      vulnerabilities: []
    };

    // Run checks
    if (this.options.checks.includes('dependencies')) {
      results.checks.dependencies = await this.checkDependencies();
    }

    if (this.options.checks.includes('headers')) {
      results.checks.headers = await this.checkSecurityHeaders();
    }

    if (this.options.checks.includes('tls')) {
      results.checks.tls = await this.checkTLSConfiguration();
    }

    if (this.options.checks.includes('secrets')) {
      results.checks.secrets = await this.checkSecretsExposure();
    }

    if (this.options.checks.includes('permissions')) {
      results.checks.permissions = await this.checkFilePermissions();
    }

    if (this.options.checks.includes('paths')) {
      results.checks.paths = await this.checkPathTraversal();
    }

    // Aggregate vulnerabilities
    results.vulnerabilities = this.vulnerabilities;
    results.summary.total = this.vulnerabilities.length;

    for (const vuln of this.vulnerabilities) {
      results.summary[vuln.severity]++;
    }

    results.duration = Date.now() - startTime;
    this.lastScan = Date.now();

    // Save report
    await this.saveReport(results);

    console.log(`[VulnScanner] Scan complete: ${results.summary.total} vulnerabilities found`);

    this.emit('scanComplete', results);

    return results;
  }

  /**
   * Check npm dependencies for known vulnerabilities
   * @returns {Promise<Object>} Check results
   */
  async checkDependencies() {
    console.log('[VulnScanner] Checking dependencies...');

    const results = {
      checked: true,
      vulnerabilitiesFound: 0,
      details: []
    };

    try {
      // Check for package.json
      const packagePath = path.join(process.cwd(), 'package.json');
      const packageContent = await fs.readFile(packagePath, 'utf8');
      const packageJson = JSON.parse(packageContent);

      // Check for outdated dependencies (simplified)
      const knownVulnerabilities = {
        // Example vulnerable packages
        'lodash': { versions: ['<4.17.21'], severity: 'high', cve: 'CVE-2020-8203' },
        'express': { versions: ['<4.17.3'], severity: 'medium', cve: 'CVE-2022-24999' }
      };

      for (const [pkg, info] of Object.entries(knownVulnerabilities)) {
        if (packageJson.dependencies && packageJson.dependencies[pkg]) {
          this.addVulnerability({
            type: 'dependency',
            severity: info.severity,
            title: `Vulnerable dependency: ${pkg}`,
            description: `Package ${pkg} has known vulnerabilities: ${info.cve}`,
            recommendation: `Update ${pkg} to a secure version`,
            cve: info.cve,
            package: pkg
          });

          results.vulnerabilitiesFound++;
        }
      }

      // Check for missing security dependencies
      const securityDeps = ['helmet', 'express-rate-limit'];
      for (const dep of securityDeps) {
        if (!packageJson.dependencies || !packageJson.dependencies[dep]) {
          this.addVulnerability({
            type: 'dependency',
            severity: 'medium',
            title: `Missing security dependency: ${dep}`,
            description: `Security package ${dep} is not installed`,
            recommendation: `Install ${dep} for enhanced security`
          });

          results.vulnerabilitiesFound++;
        }
      }

    } catch (error) {
      results.error = error.message;
    }

    return results;
  }

  /**
   * Check security headers
   * @returns {Promise<Object>} Check results
   */
  async checkSecurityHeaders() {
    console.log('[VulnScanner] Checking security headers...');

    const results = {
      checked: true,
      vulnerabilitiesFound: 0,
      missingHeaders: []
    };

    const requiredHeaders = {
      'X-Content-Type-Options': {
        value: 'nosniff',
        severity: 'medium',
        description: 'Prevents MIME type sniffing'
      },
      'X-Frame-Options': {
        value: 'DENY',
        severity: 'medium',
        description: 'Prevents clickjacking attacks'
      },
      'X-XSS-Protection': {
        value: '1; mode=block',
        severity: 'medium',
        description: 'Enables XSS filtering'
      },
      'Strict-Transport-Security': {
        value: 'max-age=31536000; includeSubDomains',
        severity: 'high',
        description: 'Enforces HTTPS connections'
      },
      'Content-Security-Policy': {
        value: "default-src 'self'",
        severity: 'high',
        description: 'Prevents XSS and injection attacks'
      }
    };

    for (const [header, config] of Object.entries(requiredHeaders)) {
      this.addVulnerability({
        type: 'security_header',
        severity: config.severity,
        title: `Missing security header: ${header}`,
        description: config.description,
        recommendation: `Set ${header} header to: ${config.value}`
      });

      results.vulnerabilitiesFound++;
      results.missingHeaders.push(header);
    }

    return results;
  }

  /**
   * Check TLS/SSL configuration
   * @returns {Promise<Object>} Check results
   */
  async checkTLSConfiguration() {
    console.log('[VulnScanner] Checking TLS configuration...');

    const results = {
      checked: true,
      vulnerabilitiesFound: 0,
      issues: []
    };

    // Check if HTTPS is enabled
    const httpsEnabled = process.env.HTTPS_ENABLED === 'true' ||
                        process.env.SSL_CERT_PATH ||
                        process.env.SSL_KEY_PATH;

    if (!httpsEnabled) {
      this.addVulnerability({
        type: 'tls',
        severity: 'critical',
        title: 'HTTPS not enabled',
        description: 'Server is not configured to use HTTPS',
        recommendation: 'Enable HTTPS with valid TLS certificates'
      });

      results.vulnerabilitiesFound++;
      results.issues.push('https_disabled');
    }

    // Check for weak TLS versions
    const minTLSVersion = process.env.MIN_TLS_VERSION || 'TLSv1.2';
    if (minTLSVersion < 'TLSv1.2') {
      this.addVulnerability({
        type: 'tls',
        severity: 'high',
        title: 'Weak TLS version',
        description: `Minimum TLS version is ${minTLSVersion}, should be at least TLSv1.2`,
        recommendation: 'Set MIN_TLS_VERSION to TLSv1.2 or higher'
      });

      results.vulnerabilitiesFound++;
    }

    return results;
  }

  /**
   * Check for secrets exposure
   * @returns {Promise<Object>} Check results
   */
  async checkSecretsExposure() {
    console.log('[VulnScanner] Checking for exposed secrets...');

    const results = {
      checked: true,
      vulnerabilitiesFound: 0,
      exposedSecrets: []
    };

    try {
      // Check .env file
      const envPath = path.join(process.cwd(), '.env');
      try {
        await fs.access(envPath);

        // .env file exists - check if it's in .gitignore
        const gitignorePath = path.join(process.cwd(), '.gitignore');
        try {
          const gitignoreContent = await fs.readFile(gitignorePath, 'utf8');
          if (!gitignoreContent.includes('.env')) {
            this.addVulnerability({
              type: 'secrets',
              severity: 'critical',
              title: '.env file not in .gitignore',
              description: 'Environment file containing secrets may be committed to repository',
              recommendation: 'Add .env to .gitignore'
            });

            results.vulnerabilitiesFound++;
          }
        } catch (error) {
          // No .gitignore file
          this.addVulnerability({
            type: 'secrets',
            severity: 'high',
            title: 'Missing .gitignore file',
            description: 'No .gitignore file found to protect sensitive files',
            recommendation: 'Create .gitignore and add sensitive files'
          });

          results.vulnerabilitiesFound++;
        }
      } catch (error) {
        // .env doesn't exist - that's okay
      }

      // Check for hardcoded secrets in code
      const secretPatterns = [
        { pattern: /password\s*=\s*['"][^'"]{8,}['"]/i, name: 'password' },
        { pattern: /api[_-]?key\s*=\s*['"][^'"]{20,}['"]/i, name: 'api_key' },
        { pattern: /secret\s*=\s*['"][^'"]{20,}['"]/i, name: 'secret' },
        { pattern: /token\s*=\s*['"][^'"]{20,}['"]/i, name: 'token' }
      ];

      // Scan common code files
      const codeFiles = await this.findFiles(process.cwd(), ['.js', '.json', '.env.example']);

      for (const file of codeFiles.slice(0, 100)) { // Limit to 100 files
        try {
          const content = await fs.readFile(file, 'utf8');

          for (const { pattern, name } of secretPatterns) {
            if (pattern.test(content)) {
              this.addVulnerability({
                type: 'secrets',
                severity: 'high',
                title: `Hardcoded ${name} detected`,
                description: `Potential hardcoded ${name} found in ${path.basename(file)}`,
                file,
                recommendation: `Move ${name} to environment variables`
              });

              results.vulnerabilitiesFound++;
              results.exposedSecrets.push({ file, type: name });
            }
          }
        } catch (error) {
          // Skip files that can't be read
        }
      }

    } catch (error) {
      results.error = error.message;
    }

    return results;
  }

  /**
   * Check file permissions
   * @returns {Promise<Object>} Check results
   */
  async checkFilePermissions() {
    console.log('[VulnScanner] Checking file permissions...');

    const results = {
      checked: true,
      vulnerabilitiesFound: 0,
      issues: []
    };

    const sensitivePaths = [
      '.env',
      'config/secrets.json',
      'private-key.pem',
      'ssl/cert.key'
    ];

    for (const filePath of sensitivePaths) {
      const fullPath = path.join(process.cwd(), filePath);

      try {
        const stats = await fs.stat(fullPath);

        // Check if file is world-readable (on Unix systems)
        if (process.platform !== 'win32') {
          const mode = stats.mode;
          const worldReadable = (mode & 0o004) !== 0;

          if (worldReadable) {
            this.addVulnerability({
              type: 'permissions',
              severity: 'high',
              title: `Sensitive file is world-readable: ${filePath}`,
              description: 'File permissions allow anyone to read sensitive data',
              recommendation: `Run: chmod 600 ${filePath}`
            });

            results.vulnerabilitiesFound++;
          }
        }
      } catch (error) {
        // File doesn't exist - that's okay
      }
    }

    return results;
  }

  /**
   * Check for path traversal vulnerabilities
   * @returns {Promise<Object>} Check results
   */
  async checkPathTraversal() {
    console.log('[VulnScanner] Checking for path traversal vulnerabilities...');

    const results = {
      checked: true,
      vulnerabilitiesFound: 0,
      issues: []
    };

    // Check for unsafe path handling patterns
    const dangerousPatterns = [
      { pattern: /req\.(query|params|body)\.\w+\s*\+\s*['"]/, desc: 'Unsanitized user input in path' },
      { pattern: /fs\.readFile\(req\./, desc: 'Direct file access with user input' },
      { pattern: /path\.join\(.*req\./, desc: 'Path construction with user input' }
    ];

    const codeFiles = await this.findFiles(process.cwd(), ['.js']);

    for (const file of codeFiles.slice(0, 50)) {
      try {
        const content = await fs.readFile(file, 'utf8');

        for (const { pattern, desc } of dangerousPatterns) {
          if (pattern.test(content)) {
            this.addVulnerability({
              type: 'path_traversal',
              severity: 'high',
              title: 'Potential path traversal vulnerability',
              description: `${desc} in ${path.basename(file)}`,
              file,
              recommendation: 'Sanitize user input and use path.resolve() with proper validation'
            });

            results.vulnerabilitiesFound++;
          }
        }
      } catch (error) {
        // Skip files that can't be read
      }
    }

    return results;
  }

  /**
   * Find files with specific extensions
   * @param {string} dir - Directory
   * @param {Array} extensions - File extensions
   * @returns {Promise<Array>} File paths
   */
  async findFiles(dir, extensions) {
    const files = [];

    async function scan(currentDir) {
      try {
        const entries = await fs.readdir(currentDir, { withFileTypes: true });

        for (const entry of entries) {
          const fullPath = path.join(currentDir, entry.name);

          // Skip node_modules and hidden directories
          if (entry.name === 'node_modules' || entry.name.startsWith('.')) {
            continue;
          }

          if (entry.isDirectory()) {
            await scan(fullPath);
          } else {
            const ext = path.extname(entry.name);
            if (extensions.includes(ext)) {
              files.push(fullPath);
            }
          }
        }
      } catch (error) {
        // Skip directories we can't access
      }
    }

    await scan(dir);
    return files;
  }

  /**
   * Add vulnerability to list
   * @param {Object} vulnerability - Vulnerability details
   */
  addVulnerability(vulnerability) {
    const vuln = {
      id: this.generateVulnId(),
      timestamp: new Date().toISOString(),
      ...vulnerability
    };

    this.vulnerabilities.push(vuln);
    this.emit('vulnerabilityFound', vuln);
  }

  /**
   * Generate vulnerability ID
   * @returns {string} Vulnerability ID
   */
  generateVulnId() {
    return `VULN-${Date.now()}-${crypto.randomBytes(4).toString('hex')}`;
  }

  /**
   * Save scan report
   * @param {Object} results - Scan results
   */
  async saveReport(results) {
    const timestamp = new Date().toISOString().replace(/:/g, '-').replace(/\..+/, '');
    const filename = `vulnerability-scan-${timestamp}.json`;
    const filepath = path.join(this.options.reportDir, filename);

    await fs.writeFile(filepath, JSON.stringify(results, null, 2), 'utf8');

    console.log(`[VulnScanner] Report saved: ${filename}`);
  }

  /**
   * Start automatic scanning
   */
  startAutoScan() {
    if (this.scanTimer) return;

    console.log(`[VulnScanner] Auto-scan enabled (interval: ${this.options.scanInterval}ms)`);

    this.scanTimer = setInterval(async () => {
      try {
        await this.scan();
      } catch (error) {
        console.error('[VulnScanner] Auto-scan failed:', error);
      }
    }, this.options.scanInterval);

    // Initial scan
    this.scan();
  }

  /**
   * Stop automatic scanning
   */
  stopAutoScan() {
    if (this.scanTimer) {
      clearInterval(this.scanTimer);
      this.scanTimer = null;
      console.log('[VulnScanner] Auto-scan disabled');
    }
  }

  /**
   * Get scan statistics
   * @returns {Object} Statistics
   */
  getStats() {
    return {
      lastScan: this.lastScan ? new Date(this.lastScan).toISOString() : null,
      totalVulnerabilities: this.vulnerabilities.length,
      bySeverity: {
        critical: this.vulnerabilities.filter(v => v.severity === 'critical').length,
        high: this.vulnerabilities.filter(v => v.severity === 'high').length,
        medium: this.vulnerabilities.filter(v => v.severity === 'medium').length,
        low: this.vulnerabilities.filter(v => v.severity === 'low').length
      }
    };
  }

  /**
   * Shutdown scanner
   */
  shutdown() {
    console.log('[VulnScanner] Shutting down...');

    this.stopAutoScan();

    console.log('[VulnScanner] Shutdown complete');
  }
}

module.exports = VulnerabilityScanner;
